
#include "round0.h"
#include "context.h"
#include "crypto-commitment/commitment.h"
#include "crypto-hash/sha256.h"
#include "crypto-curve/curve.h"
#include "crypto-bn/rand.h"
#include "../../gg18/sign/mta.h"

using std::string;
using std::vector;
using safeheron::bignum::BN;
using safeheron::curve::CurveType;
using safeheron::curve::CurvePoint;
using safeheron::curve::Curve;
using safeheron::sss::Polynomial;
using safeheron::multi_party_ecdsa::gg18::SignKey;
using safeheron::zkp::pail::PailEncRangeSetUp_V1;
using safeheron::zkp::pail::PailEncRangeStatement_V1;
using safeheron::zkp::pail::PailEncRangeProof_V1;
using safeheron::multi_party_ecdsa::gg18::sign::MtA_Step1;
using safeheron::hash::CSHA256;

static BN POW2_256 = BN(1) << 256;

namespace safeheron {
namespace multi_party_ecdsa{
namespace gg20{
namespace sign{

void CheatProve(safeheron::zkp::pail::PailEncRangeProof_V1 &alice_proof_, const PailEncRangeSetUp_V1 &setup, const PailEncRangeStatement_V1 &statement, const zkp::pail::PailEncRangeWitness_V1 &witness, BN p_i){
    const BN &N_tilde = setup.N_tilde_;
    const BN &h1 = setup.h1_;
    const BN &h2 = setup.h2_;

    const BN &c = statement.c_;
    const BN &N = statement.N_;
    const BN &N2 = statement.N2_;
    const BN &q = statement.q_;

    const BN &x = witness.x_;
    const BN &r = witness.r_;

    BN q2 = q * q;
    BN q3 = q * q2;
    BN q_N_tilde = q * N_tilde;
    BN q3_N_tilde = q2 * q_N_tilde;

    // random
    BN alpha = rand::RandomBNLt(q3);
    BN beta = rand::RandomBNLtGcd(N);
    BN gamma = rand::RandomBNLt(q3_N_tilde);
    BN rho = rand::RandomBNLt(q_N_tilde);

    // z = h1^m * h2^rho mod N_tilde
    alice_proof_.z_ = ( h1.PowM(x, N_tilde) * h2.PowM(rho, N_tilde) ) % N_tilde;
    // u = Gamma^alpha * beta^N mod N^2
    //   = ( (1+N).PowM(alpha, N2) * beta.PowM(N, N2) ) % N2;
    //   = ( (1 + alpha * N) % N2 * beta.PowM(N, N2) ) % N2;
    alice_proof_.u_ = ( (N * alpha + 1) % N2 * beta.PowM(N, N2) ) % N2;
    // w = h1^alpha * h2^gamma mod N_tilde
    alice_proof_.w_ = ( h1.PowM(alpha, N_tilde) * h2.PowM(gamma, N_tilde) ) % N_tilde;
    BN e = BN::ONE;

    // Here we brute force gamma to find an `e` that we can cheat with
    while (e % p_i != 0) {
        gamma = gamma + 1;
        alice_proof_.w_ = (alice_proof_.w_ * h2) % N_tilde;

        CSHA256 sha256;
        uint8_t sha256_digest[CSHA256::OUTPUT_SIZE];
        string str;
        N.ToBytesBE(str);
        sha256.Write((const uint8_t *)(str.c_str()), str.length());
        c.ToBytesBE(str);
        sha256.Write((const uint8_t *)(str.c_str()), str.length());
        alice_proof_.z_.ToBytesBE(str);
        sha256.Write((const uint8_t *)(str.c_str()), str.length());
        alice_proof_.u_.ToBytesBE(str);
        sha256.Write((const uint8_t *)(str.c_str()), str.length());
        alice_proof_.w_.ToBytesBE(str);
        sha256.Write((const uint8_t *)(str.c_str()), str.length());
        if(alice_proof_.salt_.length() > 0) {
            sha256.Write((const uint8_t *)(alice_proof_.salt_.c_str()), alice_proof_.salt_.length());
        }
        sha256.Finalize(sha256_digest);
        e = BN::FromBytesBE(sha256_digest, sizeof(sha256_digest));
        e = e % q;
    }
    
    alice_proof_.s_ = ( r.PowM(e, N) * beta ) % N;
    alice_proof_.s1_ = e * x + alpha;
    alice_proof_.s2_ = e * rho + gamma;
}

bool Round0::ComputeVerify() {
    bool ok = true;
    Context *ctx = dynamic_cast<Context *>(this->get_mpc_context());
    const SignKey &sign_key = ctx->sign_key_;
    const Curve * curv = GetCurveParam(sign_key.X_.GetCurveType());

    // share index array
    vector<BN> share_index_arr;
    for (size_t i = 0; i < ctx->remote_parties_.size(); ++i) {
        share_index_arr.push_back(sign_key.remote_parties_[i].index_);
    }
    share_index_arr.push_back(sign_key.local_party_.index_);

    // get lambda array
    vector<BN> &l_arr = ctx->local_party_.l_arr_;
    Polynomial::GetLArray(l_arr, BN::ZERO, share_index_arr, curv->n);
    ctx->local_party_.lambda_ = l_arr[share_index_arr.size()-1];
    for (size_t i = 0; i < ctx->remote_parties_.size(); ++i) {
        ctx->remote_parties_[i].lambda_ = l_arr[i];
    }
    ctx->local_party_.w_ = (sign_key.local_party_.x_ * ctx->local_party_.lambda_) % curv->n;

    // Sample gamma, k in Z_q
    ctx->local_party_.gamma_ = safeheron::rand::RandomBNLt(curv->n);
    ctx->local_party_.k_ = safeheron::rand::RandomBNLt(curv->n);
    if (ctx->is_malicious_) {
        ctx->local_party_.k_ = BN::ZERO;
    }
    ctx->local_party_.Gamma_ = curv->g * ctx->local_party_.gamma_;

    // Com(com_Gamma)
    ctx->local_party_.com_Gamma_blinding_factor_ = safeheron::rand::RandomBNLt(curv->n);
    ctx->local_party_.com_Gamma_ = safeheron::commitment::CreateComWithBlind(ctx->local_party_.Gamma_, ctx->local_party_.com_Gamma_blinding_factor_);

    // MTA(k, w) / MTA(k, gamma) - step 1
    ctx->local_party_.r_for_pail_for_mta_msg_a_ = safeheron::rand::RandomBNLtCoPrime(sign_key.local_party_.pail_pub_.n());
    MtA_Step1(ctx->local_party_.message_a_,
              sign_key.local_party_.pail_pub_,
              ctx->local_party_.k_,
              ctx->local_party_.r_for_pail_for_mta_msg_a_);
    if (ctx->is_malicious_) {
        MtA_Step1(ctx->local_party_.message_a_,
              sign_key.local_party_.pail_pub_,
              ctx->sign_key_.local_party_.pail_pub_.n() / ctx->p_i_,
              ctx->local_party_.r_for_pail_for_mta_msg_a_);
    }
    for (size_t i = 0; i < ctx->remote_parties_.size(); ++i) {

        PailEncRangeSetUp_V1 setup(sign_key.remote_parties_[i].N_tilde_,
                                    sign_key.remote_parties_[i].h1_,
                                    sign_key.remote_parties_[i].h2_);

        PailEncRangeStatement_V1 statement(ctx->local_party_.message_a_,
                                             sign_key.local_party_.pail_pub_.n(),
                                             sign_key.local_party_.pail_pub_.n_sqr(),
                                             curv->n);
        zkp::pail::PailEncRangeWitness_V1 witness(ctx->local_party_.k_,
                                                ctx->local_party_.r_for_pail_for_mta_msg_a_);
        ctx->remote_parties_[i].alice_proof_.Prove(setup, statement, witness);
        if (ctx->is_malicious_) {
            CheatProve(ctx->remote_parties_[i].alice_proof_, setup, statement, witness, ctx->p_i_);
        }
    }
    return true;
}

bool Round0::MakeMessage(std::vector<std::string> &out_p2p_msg_arr, std::string &out_bc_msg,
                             std::vector<std::string> &out_des_arr) const {
    Context *ctx = dynamic_cast<Context *>(this->get_mpc_context());
    const SignKey &sign_key = ctx->sign_key_;

    out_p2p_msg_arr.clear();
    out_bc_msg.clear();
    out_des_arr.clear();

    for (size_t i = 0; i < ctx->remote_parties_.size(); ++i) {
        out_des_arr.push_back(sign_key.remote_parties_[i].party_id_);
    }

    for (size_t i = 0; i < ctx->remote_parties_.size(); ++i) {
        Round0P2PMessage p2p_message;
        p2p_message.alice_proof_ = ctx->remote_parties_[i].alice_proof_;
        string base64;
        bool ok = p2p_message.ToBase64(base64);
        if (!ok) {
            ctx->PushErrorCode(1, __FILE__, __LINE__, __FUNCTION__, "Failed to encode to base64!");
            return false;
        }
        out_p2p_msg_arr.push_back(base64);
    }

    Round0BCMessage bc_message;
    bc_message.commitment_ = ctx->local_party_.com_Gamma_;
    bc_message.message_a_ = ctx->local_party_.message_a_;
    bool ok = bc_message.ToBase64(out_bc_msg);
    if (!ok) {
        ctx->PushErrorCode(1, __FILE__, __LINE__, __FUNCTION__, "Failed in bc_message.ToBase64(out_bc_msg)!");
        return false;
    }

    return true;
}

}
}
}
}
