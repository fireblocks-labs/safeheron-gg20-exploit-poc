
#include "round0.h"
#include "context.h"
#include "crypto-bn/rand.h"
#include "crypto-commitment/commitment.h"
#include "crypto-bn/rand.h"

using std::string;
using safeheron::bignum::BN;

namespace safeheron {
namespace multi_party_ecdsa {
namespace gg18 {
namespace key_gen {

/**
 * Convert a BN to a string
 *
 * @param bn BN to convert
 * @return string representation of the BN
 */
string BNToString(BN &bn) {
    string bn_string;
    bn.ToHexStr(bn_string);
    return bn_string;
}

/**
 * Create a malicious Paillier Key Pair
 *
 * @param key_bits
 */
void CreateMaliciousPaillierKeyPair(safeheron::pail::PailPrivKey &priv, safeheron::pail::PailPubKey &pub, std::vector<BN> &p_i) {
    const int private_key_size = 256;
    const int number_of_prime_factors = 16;
    const int key_bits = 2048;

    BN n = BN::ONE;
    BN p = BN::ONE;

    std::cout << "==> Generating a malicious paillier key..." << std::endl;
    std::cout << "Choosing " << number_of_prime_factors << " small primes p1,p2...p" << number_of_prime_factors << " of size greater than 2^" << private_key_size / number_of_prime_factors << std::endl;
    for (int i = 0; i < number_of_prime_factors; ++i) {
        p_i.push_back(safeheron::rand::RandomPrimeStrict((private_key_size / number_of_prime_factors) + 1));
        p = p * p_i[i];
    }

    std::cout << "Setting n=p*q where p=p1*p2...." << number_of_prime_factors << " and q is a big prime to match the expected size of n" << std::endl;
    BN q = safeheron::rand::RandomPrimeStrict(key_bits - p.BitLength());
    n = p * q;
    
    std::cout << "Setting lambda=(p1-1)*(p2-1)...(p" << number_of_prime_factors << "-1)*(q-1) and mu=lambda^-1\\mod n" << std::endl;
    BN lambda = BN::ONE;
    for (int i = 0; i < number_of_prime_factors; ++i) {
        lambda = lambda * (p_i[i] - 1);
    }
    lambda = lambda * (q - 1);
    BN mu = lambda.InvM(n);
    
    // For fast decryption
    BN g = n + 1;
    BN n_sqr = n * n;

    BN p_sqr = p * p;    // p_sqr = p^2
    BN q_sqr = q * q;    // q_sqr = q^2
    BN q_minus_1 = q - 1; // q_minus_1 = q-1
    BN p_minus_1 = lambda / q_minus_1; // p_minus_1 = p-1

    BN x = g.PowM(p_minus_1, p_sqr);
    BN lpx = (x - 1) / p;
    BN hp = lpx.InvM(p);      // hp = Lp[g^(p-1) mod p^2]^(-1) mod p

    x = g.PowM(q - 1, q_sqr);
    BN lqx = (x - 1) / q;
    BN hq = lqx.InvM(q);      // hq = Lq[g^(q-1) mod q^2]^(-1) mod q

    BN q_inv_p = q.InvM(p);   // q_inv_p = q^(-1) mod p
    BN p_inv_q = p.InvM(q);;   // p_inv_q = p^(-1) mod q

    // Set Private Key
    priv = safeheron::pail::PailPrivKey(lambda, mu, n, n * n,
                       p, q,
                       p_sqr, q_sqr,
                       p_minus_1, q_minus_1,
                       hp, hq,
                       q_inv_p, p_inv_q);

    // Set Public Key
    pub = safeheron::pail::PailPubKey(n, n + 1);

    std::cout << "Done generating a malicious paillier key" << std::endl;
}

bool Round0::ComputeVerify() {
    Context *ctx = dynamic_cast<Context *>(this->get_mpc_context());
    SignKey &sign_key = ctx->sign_key_;
    const curve::Curve *curv = curve::GetCurveParam(ctx->curve_type_);

    // Sample u \in Z_q
    ctx->local_party_.u_ = safeheron::rand::RandomBNLt(curv->n);
    ctx->local_party_.y_ = curv->g * ctx->local_party_.u_;

    // Commitment: KGC, KGD of Yi
    ctx->local_party_.kgd_y_.point_ = ctx->local_party_.y_;
    ctx->local_party_.kgd_y_.blind_factor_ = safeheron::rand::RandomBN(256);
    ctx->local_party_.kgc_y_ = safeheron::commitment::CreateComWithBlind(ctx->local_party_.y_,
                                                                         ctx->local_party_.kgd_y_.blind_factor_);

    // Generate Paillier key pair
    if (ctx->is_malicious_) {
        CreateMaliciousPaillierKeyPair(sign_key.local_party_.pail_priv_, sign_key.local_party_.pail_pub_, ctx->p_);
        
    } else {
        CreateKeyPair2048             (sign_key.local_party_.pail_priv_, sign_key.local_party_.pail_pub_);
    }

    // Generate (N_tilde, h1, h2)
    safeheron::zkp::dln_proof::GenerateN_tilde(sign_key.local_party_.N_tilde_,
                                               sign_key.local_party_.h1_,
                                               sign_key.local_party_.h2_,
                                               sign_key.local_party_.p_,
                                               sign_key.local_party_.q_,
                                               sign_key.local_party_.alpha_,
                                               sign_key.local_party_.beta_);
    // DLN Proof
    ctx->local_party_.dln_proof1_.Prove(sign_key.local_party_.N_tilde_,
                                        sign_key.local_party_.h1_,
                                        sign_key.local_party_.h2_,
                                        sign_key.local_party_.p_,
                                        sign_key.local_party_.q_,
                                        sign_key.local_party_.alpha_);
    ctx->local_party_.dln_proof2_.Prove(sign_key.local_party_.N_tilde_,
                                        sign_key.local_party_.h2_,
                                        sign_key.local_party_.h1_,
                                        sign_key.local_party_.p_,
                                        sign_key.local_party_.q_,
                                        sign_key.local_party_.beta_);

    return true;
}

bool Round0::MakeMessage(std::vector<std::string> &out_p2p_msg_arr, std::string &out_bc_msg,
                         std::vector<std::string> &out_des_arr) const {
    Context *ctx = dynamic_cast<Context *>(this->get_mpc_context());
    SignKey &sign_key = ctx->sign_key_;

    out_p2p_msg_arr.clear();
    out_bc_msg.clear();
    out_des_arr.clear();

    for (size_t i = 0; i < ctx->remote_parties_.size(); ++i) {
        out_des_arr.push_back(sign_key.remote_parties_[i].party_id_);
    }

    Round0BCMessage message;
    message.kgc_y_ = ctx->local_party_.kgc_y_;
    message.dln_proof_1_ = ctx->local_party_.dln_proof1_;
    message.dln_proof_2_ = ctx->local_party_.dln_proof2_;
    message.N_tilde_ = sign_key.local_party_.N_tilde_;
    message.h1_ = sign_key.local_party_.h1_;
    message.h2_ = sign_key.local_party_.h2_;
    message.index_ = sign_key.local_party_.index_;
    message.pail_pub_ = sign_key.local_party_.pail_pub_;
    message.ToBase64(out_bc_msg);

    return true;
}

}
}
}
}